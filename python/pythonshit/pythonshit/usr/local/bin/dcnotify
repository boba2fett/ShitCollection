#!/usr/bin/env python3
import requests
import time
import json
import os
import sys
import datetime
from pyfcm import FCMNotification
import logging
from systemd.journal import JournalHandler
from sqlalchemy import create_engine, MetaData, Table, Column, Integer, String, DateTime, Boolean
from sqlalchemy.sql import func

log = logging.getLogger("dcnotify")
log.addHandler(JournalHandler())
log.setLevel(logging.INFO)

PRE_PATH = ""#"/home/bf/git/ShitCollection/python/pythonshit"


with open(PRE_PATH+'/etc/python-shit/discordnotify.json', 'r') as json_file:
    config = json.load(json_file)
    log.info("Config loaded")

ignore = config["db_ignore"]
names = config["names"]

push_service = FCMNotification(
    api_key=config["api_key"])
registration_ids = config["registration_ids"]
headers = {
    'User-Agent': 'Mozilla/51.0 (Windows NT 6.1; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0'}

#DB
engine = create_engine('sqlite:///'+PRE_PATH +
                        '/etc/python-shit/dcdata.db')
meta = MetaData()
conn = engine.connect()

dcOn = Table(
'dcOn', meta,
Column('timestamp', DateTime(timezone=True)),
Column('username', String),
Column('status', String),
Column('channel_id', String),
Column('deaf', Boolean),
Column('mute', Boolean),
)
meta.create_all(engine)

#req=conn.execute(dcOn.select().where(dcOn.c.username=="DlieBG").order_by(dcOn.c.timestamp.desc())).first()
#print(req['status'])


def mainloop():
    lastData=None
    while True:
        try:
            data = parseData(loadNewData())
            time=datetime.datetime.now() # everyone gets same time
            sendOnlineMessages(data,lastData)
            dbCollect(data,time)
            time.sleep(290) # about every 5 min
        except Exception as e:
            sendError(e)
            time.sleep(590) # about 10 min
        finally:
            try:
                lastData=data
            except Exception as e:
                lastData=None

def parseData(data):
    data=[x for x in data if not x['username'] in ignore]
    for member in data:
        if member.get('channel_id') is None:
            member['channel_id']=None
            member['deaf']=None
            member['mute']=None
        else:
            member['deaf']=member['deaf'] or member['self_deaf']
            member['mute']=member['mute'] or member['self_mute']
    return data

def loadNewData():
    try:
        dcData = requests.get(
            config["server"], headers=headers).text  # link is under server settings widgets or similar
    except Exception as e:
        raise Exception("Server not Reachable")
    dc = json.loads(dcData)
    if (dc.get('members') is None):
        raise Exception("Ratelimited")
    data=dc['members']
    return data

def sendOnlineMessages(data,lastData):
    offline=list()
    for name in names:
        if name not in [x['username'] for x in data] and lastData is not None and name in [x['username'] for x in lastData]:
            sendOnlineMsg(name,"offline")
            offline+=name
    on=[x for x in data if x['username'] in names and x['username'] not in offline]
    for member in on:
        try:
            req=conn.execute(dcOn.select().where(dcOn.c.username==member["username"]).order_by(dcOn.c.timestamp.desc())).first()
            if req["status"] != member["status"] or lastData is None or member["username"] not in [x['username'] for x in lastData]:
                sendOnlineMsg(member["username"],member["status"])
        except Exception as e:
            log.error(f'Online Message failed because of [{str(e)}]')

def sendOnlineMsg(name,status):
    try:
        message_title = f'[{datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")}]'
        message_body = f'{name} now {status}'
        push_service.notify_multiple_devices(
            registration_ids=registration_ids, message_title=message_title, message_body=message_body)
        log.info(f'Online Message gesendet [name={name}]')
    except Exception as e:
        log.error(f'Online Message failed because of [{str(e)}]')


def dbCollect(data,time):
    for member in data:
        try:
            conn.execute(dcOn.insert().values(
                    timestamp=time,
                    username=member["username"],
                    status=member["status"],
                    channel_id=member["channel_id"],
                    deaf=member["deaf"],
                    mute=member["mute"]
                )
            )
        except Exception as e:
            sendError(Exception("DataCollection unsuccesful"))

def dbSend(data):
    for member in data:
        try:
            if requests.get(config["log_server"], headers=headers, params=
            {
                    "t":config["log_server_token"],
                    "username": member["username"],
                    "status": member["status"],
                    "channel_id": member["channel_id"],
                    "deaf": member["deaf"],
                    "mute": member["mute"]
            }
            ).status_code != 200:
                raise Exception("LogServer was not reached")
        except Exception as e:
            sendError(Exception("LogServer was not reached"))


def sendError(e):
    try:
        message_title = f'[{datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")}]'
        message_body = str(e)
        push_service.notify_multiple_devices(
            registration_ids=registration_ids, message_title=message_title, message_body=message_body)
        log.warning(f'Error Message gesendet f√ºr [{str(e)}]')

    except Exception as e2:
        log.error(
            f'Error Message failed because of [{str(e2)}] for [{str(e)}]')


mainloop()
